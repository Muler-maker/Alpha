# charts.py

from __future__ import annotations

import json
import re
from typing import Any, Dict, List, Optional

import altair as alt
import pandas as pd


# ============================================
# Internal regex to capture ```chart ... ``` blocks
# ============================================
_CHART_BLOCK_RE = re.compile(
    r"```chart\s*\n(.*?)\n```",
    re.DOTALL | re.IGNORECASE,
)


# ============================================
# Public helpers used by app.py
# ============================================
def strip_chart_blocks(answer: str) -> str:
    """
    Remove all ```chart ... ``` blocks from a markdown string.

    This is what we store as the visible chat text so users donâ€™t
    see the raw JSON.
    """
    if not answer:
        return ""

    cleaned = _CHART_BLOCK_RE.sub("", answer)
    # Normalize whitespace a bit
    return cleaned.strip()


def extract_chart_blocks(answer: str) -> List[Dict[str, Any]]:
    """
    Extract all JSON chart specs from ```chart ... ``` blocks.

    Returns a list of dicts (one per chart spec).
    """
    if not answer:
        return []

    specs: List[Dict[str, Any]] = []
    for m in _CHART_BLOCK_RE.finditer(answer):
        raw_json = m.group(1).strip()
        try:
            spec = json.loads(raw_json)
            if isinstance(spec, dict):
                specs.append(spec)
        except Exception:
            # If a block fails to parse, just skip it
            continue

    return specs


def render_chart_from_answer(answer: str) -> List[alt.Chart]:
    """
    Main entry point for the app:

    - Pull chart specs out of the answer text.
    - Build Altair charts from each spec.
    - Return a list of charts to be rendered with st.altair_chart.
    """
    charts: List[alt.Chart] = []

    for spec in extract_chart_blocks(answer):
        chart = _build_chart_from_spec(spec)
        if chart is not None:
            charts.append(chart)

    return charts


# ============================================
# Internal: build Altair charts from spec
# ============================================
def _build_chart_from_spec(spec: Dict[str, Any]) -> Optional[alt.Chart]:
    """
    Convert a single chart spec dict into an Altair chart.

    Expected spec structure (as generated by _build_chart_block in query_engine.py):

    {
      "type": "bar" | "line" | "pie",
      "xField": "Distributor",
      "yField": "Total_mCi",
      "seriesField": null or "Region",
      "aggregation": "sum_mci",
      "group_by": [...],
      "data": [ { ... row dicts ... } ]
    }
    """
    if not isinstance(spec, dict):
        return None

    chart_type = (spec.get("type") or "bar").lower()
    data = spec.get("data") or []

    if not data:
        return None

    df = pd.DataFrame(data)

    # Figure out x / y fields
    x_field = spec.get("xField")
    y_field = spec.get("yField")
    series_field = spec.get("seriesField")

    # Fallbacks if fields are missing or not found in df
    if not x_field or x_field not in df.columns:
        # First non-numeric column as x
        x_field = None
        for col in df.columns:
            if not pd.api.types.is_numeric_dtype(df[col]):
                x_field = col
                break
        if x_field is None:
            # If everything is numeric, just pick the first column
            x_field = df.columns[0]

    if not y_field or y_field not in df.columns:
        # First numeric column as y
        y_field = None
        for col in df.columns:
            if pd.api.types.is_numeric_dtype(df[col]):
                y_field = col
                break
        if y_field is None:
            # As a last resort, take the last column
            y_field = df.columns[-1]

    # ---------------------------
    # PIE CHART
    # ---------------------------
    if chart_type == "pie":
        chart = (
            alt.Chart(df)
            .mark_arc()
            .encode(
                theta=alt.Theta(field=y_field, type="quantitative"),
                color=alt.Color(field=x_field, type="nominal"),
                tooltip=[alt.Tooltip(c, type="nominal") for c in df.columns],
            )
        )
        return chart

    # ---------------------------
    # LINE CHART
    # ---------------------------
    if chart_type == "line":
        chart = (
            alt.Chart(df)
            .mark_line(point=True)
            .encode(
                x=alt.X(field=x_field, type="ordinal"),
                y=alt.Y(field=y_field, type="quantitative"),
                tooltip=[alt.Tooltip(c, type="nominal") for c in df.columns],
            )
        )
        if series_field and series_field in df.columns:
            chart = chart.encode(color=alt.Color(field=series_field, type="nominal"))
        return chart

    # ---------------------------
    # BAR CHART (default)
    # ---------------------------
    chart = (
        alt.Chart(df)
        .mark_bar()
        .encode(
            x=alt.X(field=x_field, type="ordinal"),
            y=alt.Y(field=y_field, type="quantitative"),
            tooltip=[alt.Tooltip(c, type="nominal") for c in df.columns],
        )
    )
    if series_field and series_field in df.columns:
        chart = chart.encode(color=alt.Color(field=series_field, type="nominal"))

    return chart
